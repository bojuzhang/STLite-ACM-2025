## priority_queue 复杂度分析报告

本项目选取斜堆实现 priority_queue

### 各操作复杂度分析
```merge``` 的复杂度稍后证明

#### top
直接返回根节点对应的值，复杂度 $O(1)$

#### push
将加入的新节点看作一个单点构成的堆，复杂度为 ```merge``` 的均摊 $O(\log n)$

#### pop
将根节点的左右子树合并，复杂度亦为 ```merge``` 的均摊 $O(\log n)$

#### merge 
复杂度为均摊 $O(\log n)$

#### size
维护堆自身 size 直接返回，复杂度 $O(1)$

#### empty
判断堆自身 size 是否非空，复杂度 $O(1)$

### 斜堆 merge 操作的均摊复杂度证明

若一个节点的右子树大小不小于以该节点为根的子树大小的一半，则称这个节点为重节点，否则为轻节点。

定义斜堆的势为该斜堆中重节点的个数。

设 $h_1,l_1,h_2,l_2$ 分别为第一个堆的极右路径上重节点的个数，第一个堆的极右路径上轻节点的个数，第二个堆的极右路径上重节点的个数，第二个堆的极右路径上轻节点的个数。

则该次 merge 操作的代价为 $c_i = h_1 + l_1 + h_2 + l_2$，即沿着右路径一路下来的长度。

发现一个重节点在合并后会由于左右子树的交换变为轻节点，因此势能改变量最坏情况下为 $\Delta t_i = l_1 + l_2 - (h_1 + h_2)$，即所有轻节点变为重节点。

令 $k_i = c_i + \Delta t_i$，则 $k_i = 2(l_1 + l_2)$。

由于每个轻节点的右子树小于以该节点为根的子树大小的一半，故轻节点个数是 $O(\log n)$ 级别的。

则 $\sum c_i = \sum (k_i - \Delta t_i) = \sum k_i - t_n + t_0$。

易知 $t_n = O(n), t_0 = 0$。

故 $\sum c_i = O(n\log n)$，即均摊复杂度为 $O(\log n)$。